[
  {
    "objectID": "preparacion.html",
    "href": "preparacion.html",
    "title": "Preparativos para el taller",
    "section": "",
    "text": "Se hace de forma gratuita en GitHub."
  },
  {
    "objectID": "preparacion.html#crear-una-cuenta-en-github",
    "href": "preparacion.html#crear-una-cuenta-en-github",
    "title": "Preparativos para el taller",
    "section": "",
    "text": "Se hace de forma gratuita en GitHub."
  },
  {
    "objectID": "preparacion.html#instalar-el-paquete-de-r-usethis",
    "href": "preparacion.html#instalar-el-paquete-de-r-usethis",
    "title": "Preparativos para el taller",
    "section": "2 Instalar el paquete de R usethis",
    "text": "2 Instalar el paquete de R usethis\n\ninstall.packages(\"usethis\")"
  },
  {
    "objectID": "preparacion.html#instalar-git",
    "href": "preparacion.html#instalar-git",
    "title": "Preparativos para el taller",
    "section": "3 Instalar Git",
    "text": "3 Instalar Git\n\nWindows:\n\nDescargar la distribución Git for Windows de acá o acá (cualquiera es lo mismo).\nSi bien hay otras opciones, Git for Windows trae otras herramientas además de Git y deja el ejecutable en una ubicación donde RStudio y otros programas lo encuentran fácilmente.\nDurante la instalación, aceptar todas las opciones por defecto haciendo clic en “Next”, prestando atención a estas dos opciones:\n\nEn la parte de “Choosing the default editor used by Git”, elegir el Bloc de notas o Notepad.\nEn la parte de “Adjusting your PATH environment” asegurarse que tengamos seleccionada la opción “Git from the command line and also from 3rd-party software”.\n\n\n\n\n\nLinux: sudo apt-get install git\nMac: instrucciones"
  },
  {
    "objectID": "preparacion.html#configurar-git",
    "href": "preparacion.html#configurar-git",
    "title": "Preparativos para el taller",
    "section": "4 Configurar Git",
    "text": "4 Configurar Git\n\nSe realiza una sola vez en cada computadora.\nHay que indicar un nombre de usuario y correo.\nNo es necesario que el nombre sea el mismo que el de tu cuenta de GitHub. De hecho, si usás Git en distintas computadoras (notebook, PC, oficina) podrías incorporar esta info en el nombre de usuario que elijas en cada una (ej: “marcos-oficina”), o usar en todos lados el mismo.\nSin embargo, el correo siempre debe ser el mismo que el de tu cuenta de GitHub.\nVamos a hacer esto en R con el paquete usethis, que incluye funciones útiles para desarrolladores, entre ellas algunas que nos permiten usar Git indirectamente a través de R, evitándonos hacer uso de una terminal.\nCorrer el siguiente código:\n\n\nlibrary(usethis)\nuse_git_config(user.name = \"minombre\", user.email = \"micorreo@proveedor.com\")"
  },
  {
    "objectID": "preparacion.html#conectar-git-con-github",
    "href": "preparacion.html#conectar-git-con-github",
    "title": "Preparativos para el taller",
    "section": "5 Conectar git con GitHub",
    "text": "5 Conectar git con GitHub\n\nCada vez que nuestra instalación local de Git quiera interactuar con el servidor remoto de GitHub, tiene que presentar ciertas credenciales para certificar que tiene los permisos correspondientes.\nLamentablemente, por cuestiones de seguridad, no es suficiente con poner nuestra contraseña de GitHub en algún lugar.\nHay que usar un protocolo para el acceso y uso seguro de servidores remotos.\nPara esto se puede elegir entre dos opciones, el protocolo HTTPS (un poco más sencillo e ideal para dar los primeros pasos) y el protocolo SSH (un poco más seguro, usando unas “llaves” que se guardan y machean local y remotamente).\nVamos a elegir la primera opción.\n\nCrear un personal access token o PAT en GitHub.\n\nPodemos ir a crearlo en https://github.com/settings/tokens/new, pero es más fácil si desde R corremos el siguiente código, que nos llevará a la misma web pero habiendo elegido algunos valores por default para definir los permisos que son los recomendados:\n\nusethis::create_github_token()\n\nEn NOTE ponemos una descripción del token. Potencialmente podríamos usar varios PATs, por ejemplo, uno por cada máquina en la que trabajo. Ponerle una descripción nos permite identificar cada PAT en el listado de tokens de GitHub y eventualmente eliminar los que ya no usemos.\nNotar que el token tiene una fecha de expiración, por seguridad. Pasada la misma, podemos crear otro PAT de la misma forma.\nDejar los permisos como están y hacer clic abajo en Generate token.\nAparece una ventana que nos muestra el token. ¡Es la única vez que lo veremos!. Así que no cierres esa ventana sin copiarlo al portapapeles (o dejalo por unos minutos pegado en un bloc de notas o algo así).\n\nAlmacenar el PAT en algún sistema de credenciales o contraseñas.\n\nEl PAT es como una contraseña, no debería estar anotado en ningún lugar o archivo, ni lo deberíamos dejar escrito en nuestros scripts.\nHay personas que utilizan aplicaciones para administrar sus contraseñas, ese podría ser un lugar para guardarlo.\nGit ofrece un sistema de manejo de credenciales para ayudarnos con esto (git credential store) y lo podemos usar muy fácilmente mediante el paquete de R gitcreds (que vino junto a la instalación del paquete usethis).\nSólo tenemos que correr la siguiente línea y pegar el PAT cuando es solicitado:\ngitcreds::gitcreds_set()\n\n? Enter password or token: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n-&gt; Adding new credentials...\n-&gt; Removing credentials from cache...\n-&gt; Done.\nDe esta forma nuestra instalación local de git queda autentificada para trabajar remotamente con GitHub.\nComo este sistema de credenciales funciona un poco como un caché de un explorador web, puede ser que después de algún tiempo por seguridad no se encuentre más nuestra credencial. En caso de que GitHub nos deniegue el acceso, podemos crear un nuevo token de la misma forma.\nEn Linux todo lo anterior no anda así tan sencillamente, es más fácil usar el protocolo SSH."
  },
  {
    "objectID": "preparacion.html#eliminar-credenciales-opcional",
    "href": "preparacion.html#eliminar-credenciales-opcional",
    "title": "Preparativos para el taller",
    "section": "6 Eliminar credenciales (opcional)",
    "text": "6 Eliminar credenciales (opcional)\n\nSi después de realizar el taller necesitás borrar las credenciales de la compu que usaste, podés utilizar:\n\n\ngitcreds_delete()"
  },
  {
    "objectID": "presentacion.html#investigación-o-trabajo-reproducible",
    "href": "presentacion.html#investigación-o-trabajo-reproducible",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Investigación o trabajo reproducible",
    "text": "Investigación o trabajo reproducible\n\nLa investigación científica (y todo trabajo que pretenda ser serio) se basa en un principio fundamental: garantizar la posibilidad de reproducir los resultados alcanzados.\n\n\n\n\n\n\n\nImportante\n\n\nEn el análsis de datos se considera que una investigación o trabajo es reproducible cuando los resultados exactos pueden reproducirse si se tiene acceso a los datos, al software y al código usados."
  },
  {
    "objectID": "presentacion.html#requisitos-de-la-investigación-reproducible",
    "href": "presentacion.html#requisitos-de-la-investigación-reproducible",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Requisitos de la investigación reproducible",
    "text": "Requisitos de la investigación reproducible\n\nEn la práctica, algunas organizaciones (por ejemplo, agencias de financiamiento, editores de revistas) exigen particularmente:\n\nQue los datos y el código se publiquen en algún repositorio.\nQue sea posible crear las tablas y gráficos derivados de los datos ejecutando el código.\nQue se enumeren los detalles sobre el sistema que se utiliza para ejecutar el análisis: sistema operativo, parches, semillas de números aleatorios, versiones específicas del software o paquetes.\nQue el código esté escrito de una manera que se pueda entender fácilmente."
  },
  {
    "objectID": "presentacion.html#requisitos-de-la-investigación-reproducible-1",
    "href": "presentacion.html#requisitos-de-la-investigación-reproducible-1",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Requisitos de la investigación reproducible",
    "text": "Requisitos de la investigación reproducible\n\n\nQue los informes y documentos de salida también se generen utilizando código (es decir, se proporcione un archivo o archivos que, cuando se ejecutan, importan los datos, producen todos los resultados, insertan los resultados en el texto del informe y dan formato al informe).\n\n\n\nThe Turing Way project illustration by Scriberia. Used under a CC-BY 4.0 licence. DOI: 10.5281/zenodo.3332807."
  },
  {
    "objectID": "presentacion.html#beneficios-de-la-investigación-reproducible",
    "href": "presentacion.html#beneficios-de-la-investigación-reproducible",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Beneficios de la investigación reproducible",
    "text": "Beneficios de la investigación reproducible\n\nFacilita la verificación de la investigación de forma independiente.\nFacilita la extensión y continuación del trabajo.\nGenera mayor eficiencia al producir código reutilizable (aunque al principio puede parecer que realizar análisis de manera reproducible y automatizada lleva más tiempo y es más difícil).\nIncrementa las chances de que la investigación sea correcta."
  },
  {
    "objectID": "presentacion.html#beneficios-de-la-investigación-reproducible-1",
    "href": "presentacion.html#beneficios-de-la-investigación-reproducible-1",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Beneficios de la investigación reproducible",
    "text": "Beneficios de la investigación reproducible"
  },
  {
    "objectID": "presentacion.html#algunos-pilares-de-la-investigación-reproducible",
    "href": "presentacion.html#algunos-pilares-de-la-investigación-reproducible",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Algunos pilares de la investigación reproducible",
    "text": "Algunos pilares de la investigación reproducible\n\nAutomatización de tareas relacionadas a la comunicación y publicación de resultados.\nCuidadosa importación de datos en el software.\nOrganización del trabajo de análisis de datos en**proyectos*.\nImplementación de un sistema de control de versiones."
  },
  {
    "objectID": "presentacion.html#sistemas-de-control-de-versiones-1",
    "href": "presentacion.html#sistemas-de-control-de-versiones-1",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Sistemas de control de versiones",
    "text": "Sistemas de control de versiones\n\nEn cualquier proyecto de análisis de datos enseguida se generan muchísimos archivos, que van evolucionando en el tiempo, generando distintas versiones."
  },
  {
    "objectID": "presentacion.html#sistemas-de-control-de-versiones-2",
    "href": "presentacion.html#sistemas-de-control-de-versiones-2",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Sistemas de control de versiones",
    "text": "Sistemas de control de versiones\n\n\nComo si fuera poco, estos contenidos generalmente deben ser compartidos o se producen trabajando colaborativamente con otras personas.\nSin una forma organizada de manejar todo esto, es fácil caer en un caos de archivos, versiones, mails con adjuntos, etc., que le roban tiempo al trabajo principal y pueden reducir la calidad del producto final.\nContamos con algunos servicios de almacenamiento en la nube como Google Drive o Onedrive que ayudan a tener archivos sincronizados entre distintas computadoras. Sin embargo, las herramientas que ofrecen para la administración de versiones y el trabajo en equipo son limitadas.\nPara esto existen específicamente los sistemas de control de versiones."
  },
  {
    "objectID": "presentacion.html#sistemas-de-control-de-versiones-3",
    "href": "presentacion.html#sistemas-de-control-de-versiones-3",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Sistemas de control de versiones",
    "text": "Sistemas de control de versiones\n\n\nEn este taller veremos los pasos iniciales en el uso de un sistema de este tipo llamado Git y un servicio web de hosting llamado GitHub.\nDebemos notar que para alguien que trabaja solo en proyectos de pequeña escala, tal vez no valga la pena pasar por este aprendizaje que puede ser un poco doloroso.\nPero incursionar en esto se vuelve necesario a medida que deseamos interactuar con la comunidad, participar en proyectos de mayor dimensión, tomar herramientas metodológicas producidas por otras personas, integrar proyectos comunitarios de enseñanza, publicar nuestro trabajo de investigación o nuestros desarrollos, sumar herramientas valoradas en el mercado laboral, etc."
  },
  {
    "objectID": "presentacion.html#qué-es-control-de-versiones",
    "href": "presentacion.html#qué-es-control-de-versiones",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Qué es control de versiones",
    "text": "Qué es control de versiones\n\nUn sistema de control de versiones toma inicialmente una versión de un documento y luego registra los cambios que sufre el mismo a lo largo del tiempo.\nSi más de una persona trabaja en el mismo documento, el sistema de control de versiones puede integrar las distintas versiones en una nueva."
  },
  {
    "objectID": "presentacion.html#commits-y-repos",
    "href": "presentacion.html#commits-y-repos",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Commits y repos",
    "text": "Commits y repos\n\n\nCada una de estas versiones recibe el nombre de commit y el sistema registra información útil (metadata) sobre las mismas.\nEl conjunto completo de todos los commits, su metadata y todos los archivos involucrados en el control de versiones de un proyecto, recibe el nombre de repo (repositorio, repository).\nPodemos imaginarnos un repo sencillamente como una carpeta de la computadora que sabe cómo guardar todo eso.\nEl sistema provee herramientas para mantener sincronizados los repos en distintas computadoras o servicios de hosting, facilitando la colaboración entre personas."
  },
  {
    "objectID": "presentacion.html#beneficios-de-emplear-un-sistema-de-control-de-versiones",
    "href": "presentacion.html#beneficios-de-emplear-un-sistema-de-control-de-versiones",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Beneficios de emplear un sistema de control de versiones",
    "text": "Beneficios de emplear un sistema de control de versiones\n\n\nHace que pensemos en la organización y distribución de nuestro trabajo.\nLa colaboración entre personas sea hace de forma estructurada.\nAutomáticamente disponemos de presencia online para nuestro proyecto.\nSi estamos desarrollando alguna pieza de software (como un paquete de R o una librería de Python), lo podemos compartir por este medio.\nPermite publicar el código y los resultados que acompañan a nuestras publicaciones.\nGuarda de forma organizada versiones viejas de los archivos indefinidamente."
  },
  {
    "objectID": "presentacion.html#qué-es-git",
    "href": "presentacion.html#qué-es-git",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Qué es Git",
    "text": "Qué es Git\n\n\nGit es un sistema de control de versiones.\nHay muchos sistemas de este estilo, pero utilizaremos Git porque ha ganado gran popularidad en el mundo del análisis de datos.\nGit es el software que instalamos localmente para registrar los cambios.\nSe maneja con comandos desde una terminal."
  },
  {
    "objectID": "presentacion.html#qué-es-github",
    "href": "presentacion.html#qué-es-github",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Qué es GitHub",
    "text": "Qué es GitHub\n\n\n\nGitHub es una interfaz gráfica online que complementa a Git y que provee un mecanismo de distribución para los repos.\nPara llevarlo a terreno conocido, GitHub es a Git lo que RStudio es a R (más o menos).\nPodemos usar Git sin GitHub, pero el último agrega muchas herramientas útiles.\nGitHub es el servicio de hosting que utilizaremos para que nuestro proyecto tenga presencia online, permitiéndole a otras personas explorar los archivos, su historia, sincronizarse con la versión actual, proponer y realizar cambios, etc.\nHay otras plataformas que cumplen esta función, como GitLab or BitBucket, pero en este taller nos centramos en esta."
  },
  {
    "objectID": "presentacion.html#git-github-rstudio",
    "href": "presentacion.html#git-github-rstudio",
    "title": "Taller sobre Git + GitHub + RStudio",
    "section": "Git + GitHub + RStudio",
    "text": "Git + GitHub + RStudio\n\nGit + GitHub es, por ejemplo, el entorno más popular para los desarrolladores de paquetes de R.\nEn este taller no vamos a hacer mucha distinción entre qué cosa es de Git y cuál otra es de GitHub.\nEs más, vamos a usar estas herramientas desde RStudio, sin hacer uso en ningún momento de la terminal.\n\n¡Ya estamos listos para empezar!\n\n\n\n\nVolver al inicio"
  },
  {
    "objectID": "taller-git.html",
    "href": "taller-git.html",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "",
    "text": "Existen varias formas de crear un nuevo git repo, ya sea para un proyecto que vamos a arrancar desde cero o para otro ya existente.\nEn este tutorial seguiremos un camino muy particular: vamos a crear el repo en GitHub para luego traerlo a nuestra computadora utilizando las herramientas de RStudio.\n¿Por qué seguiremos este camino? RStudio simplifica algunas cuestiones haciéndolas automáticamente sin que lo notemos, de modo que podamos dar más rápido nuestros primeros pasos.\n\n\n\n\n\n\n\nPasos para crear un nuevo repo en GitHub\n\n\n\nNota: esto se realiza una sola vez para cada proyecto/trabajo.\n\nEntrar a tu cuenta en GitHub.\nCliquear en el + de arriba a la derecha y luego New Repository (o directamente ir a https://github.com/new).\nElegir un nombre, agregar una descripción, indicar si será un repo público o privado (elegir público para el taller), cliquear que sí queremos tener un archivo README y finalmente cliquear Create Repository.\n\n\n\n\n\n\n\n\n\n\n\nEsto crea una página web llamada github.com/usuario/nombrerepo (en mi caso, https://github.com/mpru/marcos_aprende_git), que es sólo visible para nosotros si seleccionamos Privado o para cualquiera si pusimos Público.\nPor ahora, esta página nos muestra que el repo tiene sólo un archivo, el README.md, cuyo contenido lo podemos ver abajo e incluye lo que pusimos como descripción del repo.\n\n\n\n\n\n\n\n\n\n\n\nPara terminar, copiar la dirección del repo (en mi caso: https://github.com/mpru/marcos_aprende_git, también disponible en el botón verde Clone or download).\n\n\n\nAcerca del archivo README\n\nUn README es un archivo de texto plano que se utiliza para documentar o brindar informacióon sobre alguna pieza de software o proyecto.\nSi un directorio contiene un archivo README, se espera que el usuario lo lea antes de explorar el resto del contenido.\nEn el contexto de un repo de GitHub, el README se suele escribir en Markdown (por eso su extensión .md) y describe brevemente el contenido del repo, instrucciones para su uso, explicaciones acerca de cómo navegar por su contenido, etc.\nEl contenido de este archivo es lo que se muestra en la página principal del repo, por lo tanto es su carta de presentación.\nPodemos editar este archivo en cualquier momento.\n\n\n\n\n\nVamos a utilizar RStudio para clonar el repo de GitHub en nuestra compu.\n\n\n\n\n\n\n\nPasos para clonar un repo\n\n\n\nClonar significa descargar una copia del repo tal como está en GitHub en nuestra compu, incluyendo ciertas configuraciones para que ambos queden vinculados y podamos, más adelante, enviar cambios y archivos automáticamente entre uno y otro.\nNota: esto se realiza una sola vez en cada computadora.\n\nComenzar un nuevo proyecto en RStudio: File &gt; New Project &gt; Version Control &gt; Git.\nPegar la dirección copiada en GitHub en Repository URL.\nElegir con cuidado dónde queremos alojar este proyecto en la compu.\nCrear proyecto.\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservar que se creó una carpeta con el nombre del repo que contiene el archivo README que estaba en GitHub.\nSe descargaron algunas otras cositas, entre ellas una carpeta oculta llamada .git, que es la que Git utiliza para almacenar toda la información del repo, incluyendo archivos de configuración y una base de datos que registra todos los cambios realizados en los archivos. Si alguna vez borramos el directorio .git, perderemos la historia del proyecto y todo el control de versiones.\nAdemás, nos damos cuenta de que estamos trabajando en un git repo porque en el panel de arriba a la derecha de RStudio tenemos la pestaña “Git” y en la barra de herramientas hay un menú desplegable también llamado Git.\n\n\n\n\n\n\n\n\n\n\n\nA la carpeta descargada en nuestra compu le decimos repo local y a su versión hospedada en GitHub le decimos remoto o remote.\nUn remote de un repo es otro repo con el cual está vinculado, de modo que ambos se pueden mantener sincronizados a través del intercambio de commits.\n\n\n\n\n\n\n\n\n\n\nRepresentación de ambos repos. La parte superior en gris representa al servidor remoto de GitHub. La parte blanca inferior es nuestra propia compu.\n\n\n\n\n\nNota: en RStudio, sólo se puede acceder a las herramientas de control de versiones si estamos trabajando dentro de un RProject."
  },
  {
    "objectID": "taller-git.html#pasosrepo",
    "href": "taller-git.html#pasosrepo",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "",
    "text": "Existen varias formas de crear un nuevo git repo, ya sea para un proyecto que vamos a arrancar desde cero o para otro ya existente.\nEn este tutorial seguiremos un camino muy particular: vamos a crear el repo en GitHub para luego traerlo a nuestra computadora utilizando las herramientas de RStudio.\n¿Por qué seguiremos este camino? RStudio simplifica algunas cuestiones haciéndolas automáticamente sin que lo notemos, de modo que podamos dar más rápido nuestros primeros pasos.\n\n\n\n\n\n\n\nPasos para crear un nuevo repo en GitHub\n\n\n\nNota: esto se realiza una sola vez para cada proyecto/trabajo.\n\nEntrar a tu cuenta en GitHub.\nCliquear en el + de arriba a la derecha y luego New Repository (o directamente ir a https://github.com/new).\nElegir un nombre, agregar una descripción, indicar si será un repo público o privado (elegir público para el taller), cliquear que sí queremos tener un archivo README y finalmente cliquear Create Repository.\n\n\n\n\n\n\n\n\n\n\n\nEsto crea una página web llamada github.com/usuario/nombrerepo (en mi caso, https://github.com/mpru/marcos_aprende_git), que es sólo visible para nosotros si seleccionamos Privado o para cualquiera si pusimos Público.\nPor ahora, esta página nos muestra que el repo tiene sólo un archivo, el README.md, cuyo contenido lo podemos ver abajo e incluye lo que pusimos como descripción del repo.\n\n\n\n\n\n\n\n\n\n\n\nPara terminar, copiar la dirección del repo (en mi caso: https://github.com/mpru/marcos_aprende_git, también disponible en el botón verde Clone or download).\n\n\n\nAcerca del archivo README\n\nUn README es un archivo de texto plano que se utiliza para documentar o brindar informacióon sobre alguna pieza de software o proyecto.\nSi un directorio contiene un archivo README, se espera que el usuario lo lea antes de explorar el resto del contenido.\nEn el contexto de un repo de GitHub, el README se suele escribir en Markdown (por eso su extensión .md) y describe brevemente el contenido del repo, instrucciones para su uso, explicaciones acerca de cómo navegar por su contenido, etc.\nEl contenido de este archivo es lo que se muestra en la página principal del repo, por lo tanto es su carta de presentación.\nPodemos editar este archivo en cualquier momento."
  },
  {
    "objectID": "taller-git.html#pasostraer",
    "href": "taller-git.html#pasostraer",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "",
    "text": "Vamos a utilizar RStudio para clonar el repo de GitHub en nuestra compu.\n\n\n\n\n\n\n\nPasos para clonar un repo\n\n\n\nClonar significa descargar una copia del repo tal como está en GitHub en nuestra compu, incluyendo ciertas configuraciones para que ambos queden vinculados y podamos, más adelante, enviar cambios y archivos automáticamente entre uno y otro.\nNota: esto se realiza una sola vez en cada computadora.\n\nComenzar un nuevo proyecto en RStudio: File &gt; New Project &gt; Version Control &gt; Git.\nPegar la dirección copiada en GitHub en Repository URL.\nElegir con cuidado dónde queremos alojar este proyecto en la compu.\nCrear proyecto.\n\n\n\n\n\n\n\n\n\n\n\n\n\nObservar que se creó una carpeta con el nombre del repo que contiene el archivo README que estaba en GitHub.\nSe descargaron algunas otras cositas, entre ellas una carpeta oculta llamada .git, que es la que Git utiliza para almacenar toda la información del repo, incluyendo archivos de configuración y una base de datos que registra todos los cambios realizados en los archivos. Si alguna vez borramos el directorio .git, perderemos la historia del proyecto y todo el control de versiones.\nAdemás, nos damos cuenta de que estamos trabajando en un git repo porque en el panel de arriba a la derecha de RStudio tenemos la pestaña “Git” y en la barra de herramientas hay un menú desplegable también llamado Git.\n\n\n\n\n\n\n\n\n\n\n\nA la carpeta descargada en nuestra compu le decimos repo local y a su versión hospedada en GitHub le decimos remoto o remote.\nUn remote de un repo es otro repo con el cual está vinculado, de modo que ambos se pueden mantener sincronizados a través del intercambio de commits.\n\n\n\n\n\n\n\n\n\n\nRepresentación de ambos repos. La parte superior en gris representa al servidor remoto de GitHub. La parte blanca inferior es nuestra propia compu.\n\n\n\n\n\nNota: en RStudio, sólo se puede acceder a las herramientas de control de versiones si estamos trabajando dentro de un RProject."
  },
  {
    "objectID": "taller-git.html#fork",
    "href": "taller-git.html#fork",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "6.1 Fork",
    "text": "6.1 Fork\n\nEn este material, yo, con el usuario mpru (github.com/mpru), voy a contribuir al repo ProyectoInteresante de la cuenta de otro usario llamado AprendizGit2 (github.com/AprendizGit2/ProyectoInteresante) y esta persona, más tarde, va a aceptar mi contribución.\nEstando logueado en mi cuenta de GitHub, voy a la web del repo ProyectoInteresante de AprendizGit2 y hago clic en el botón Fork.\n\n\n\n\n\n\n\nFork\n\n\n\nHacer un fork es crear una copia exacta de un repo ajeno en mi cuenta de GitHub. A partir de ahora, tengo mi propio repo ProyectoInteresante en mi cuenta.\n\n\n\n\n\n\n\n\n\n\n\nLa captura puede no coincidir exactamente con el aspecto actual de GitHub, puesto que el mismo cambia frecuentemente, pero el contenido es equivalente. Notar que en la figura el usuario dice AprendizGit, cuando en verdad es AprendizGit2.\n\n\n\n\n\nTodas las modificaciones que quiera hacer, las voy a hacer en mi repo, en mi cuenta.\nEn este momento, tenemos un repo en GitHub en el cual queremos trabajar. Estamos en la misma situación que cuando terminamos de crear un repo nuevo en GitHub al inicio del taller.\nTenemos que clonarlo para traerlo a mi compu (es decir, hacer un famoso fork & clone), empezar a trabajar localmente y pushear el trabajo hecho a nuestro repo en GitHub.\n\n\n\n\n\n\n\n\n\n\nRepresentación de tres repos. La parte superior en gris representa al servidor remoto de GitHub. La parte blanca inferior es nuestra propia compu.\n\n\n\n\n\nPara mantener el ejemplo corto y sencillo, sin necesidad de hacer otras configuraciones, no vamos a hacer el clone y sólo trabajaremos remotamente en nuestro repo de GitHub.\nPor ejemplo, voy a agregar un nuevo archivo llamado analisis.R, haciendo clic en Add file:\n\n\n\n\n\n\n\n\n\n\nSubir un archivo al repo en GitHub. Las capturas no coinciden exactamente con la versión actual de GitHub, pero todo es equivalente.\n\n\n\n\n\nPara poder hacer una modificación online, hay que realizar el respectivo commit, por eso tenemos que escribir su mensaje y hacer clic en el botón commit."
  },
  {
    "objectID": "taller-git.html#pull-request",
    "href": "taller-git.html#pull-request",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "6.2 Pull request",
    "text": "6.2 Pull request\n\nCuando considere que mi contribución está terminada, le voy a proponer a AprendizGit2 que considere incluir mis cambios a través de un pull request.\nSi esta persona está de acuerdo, los aceptará con un merge.\n\n\n\n\n\n\n\nPull request y merge\n\n\n\nUn pull request o pedido de pull es una petición que hacemos para que el dueño del repo en el que estamos colaborando integre nuestras propuestas o cambios a su código. Es la forma de avisarle que tenemos algo para contribuir y pedirle que lo revise.\nEl merge o unión tendrá lugar cuando esa persona acepte nuestra propuesta e implica que la fusión entre su versión del repo y la nuestra.\n\n\n\nPara lograr esto:\n\nHacemos clic en el botón Contribute y luego en Open pull request, o en el botón Pull request y luego en New pull request.\nEn la siguiente ventana podemos darle un título a nuestro cambio propuesto y describir con detalle el por qué de la sugerencia en el cuadro de texto. Cuando terminamos, hacemos clic en Create pull request.\nLa tercera página es la web del pull request que ya fue realizado, donde podría seguir la conversación entre distintas personas sobre estos cambios propuestos.\n\n\n\n\n\n\n\n\n\n\n\nPull request en GitHub. Las capturas no coinciden exactamente con la versión actual de GitHub, pero todo es equivalente.\n\n\n\n\n\nAl dueño del repo, en nuestro ejemplo AprendizGit2, le llega una notificación para que venga a mirar esto:\n\n\nAprendizGit2 entra a su repo, va a la pestaña Pull requests y se encuentra con el listado de todos los pull requests que ha recibido (uno solo en este ejemplo).\nAprendizGit2 hace clic en el pull request y entra en una página donde puede ver el mensaje que le dejé yo, puede responderme y puede explorar los cambios y archivos involucrados. Si le parece bien, puede hacer clic en Merge pull request para adoptar estos cambios.\nUna vez hecho el merge, en la página del pull request queda registrada toda esta historia.\nY si volvemos al repo ProyectoInteresante de AprendizGit2 vemos que el cambio aportado, que, recordamos, se trataba de haber agregado un nuevo archivo llamado analisis.R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjercicio 1\n\n\n\nSeguí los pasos anteriores para hacer tu propia contribución al repo ProyectoInteresante del usuario AprendizGit2. Agregá un nuevo archivo, tal vez puedas usar tu nombre como nombre del archivo (no edites uno existente, para evitar posibles complicaciones que escapan al alcance de este taller).\nUna vez que termines, podrías probar de hacer otra contribución en un repo de algún/a compañero/a.\n\n\n\n\n\n\n\n\nPara tener en cuenta\n\n\n\n\nPara simplificar el proceso, hicimos un ejemplo en el que sólo trabajamos en GitHub. Con esto logramos nuestro objetivo de armarnos una idea general sobre el tema. Sin embargo, la gran potencia de estos sistemas es poder trabajar localmente. No es mucho más complejo que lo que ya hicimos, pero se necesitan hacer otras configuraciones para mantener todo bien ordenadito: nuestro repo local, nuestro repo remoto (generalmente identificado como origin) y el repo original de la otra persona al que queremos contribuir (conocido como upstream).\nUn repo puede tener varias “vías” paralelas de trabajo, que se llaman branches. Se recomienda no trabajar en la main branch de un repo forkeado como hicimos recién, sino hacer los cambios que queramos en otra branch, como para no mezclar lo que hacemos nosotros con lo que ya estaba, hasta no estar seguros del todo. Más adelante se retoma esta idea, pero si trabajo de forma individual o con pocas personas, podemos omitirlo, en especial si estamos dando nuestros primeros pasos en este universo.\nMientras yo estuve trabajando en mi repo local, puede que el dueño del repo original (AprendizGit2) también haya estado haciendo lo suyo y mi versión ya esté actualizada. Es necesario asegurarse de que podamos estar sincronizados con el repo original (upstream).\n\nEstos temas se abordan en la sección “Más detalles”. Por ahora, con lo que vimos alcanza."
  },
  {
    "objectID": "taller-git.html#invitar-colaboradores-a-un-repo",
    "href": "taller-git.html#invitar-colaboradores-a-un-repo",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "6.3 Invitar colaboradores a un repo",
    "text": "6.3 Invitar colaboradores a un repo\n\nTodo lo anterior de fork & clone sirve siempre y cuando estemos copiando y contribuyendo a un repo público.\nSi tenemos un repo privado y queremos hacer que alguien más pueda participar del mismo, podemos invitarlos a participar como colaboradores.\nComo colaborador de un repositorio personal, esa persona podrá hacer pull y push directamente a ese repositorio, sin tener que hacer ningún pull request.\nPara agregar un colaborador hay que:\n\nIr a la web del repo en GitHub.\nHacer clic en Settings.\nHacer clic en Collaborators del panel de la izquierda.\nHacer clic en el botón Add people.\nUbicar a la persona a invitar mediante su nombre de usuario o email.\nHacer clic en Add to this repository.\n\nLa persona invitada recibirá una notificación por correo o en su GitHub con la invitación, que deberá aceptar dentro de los próximos 7 días o caducará."
  },
  {
    "objectID": "taller-git.html#organizaciones",
    "href": "taller-git.html#organizaciones",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "6.4 Organizaciones",
    "text": "6.4 Organizaciones\n\nOtra forma de armar el trabajo comunitario en GitHub es en el contexto de las organizaciones.\nLas organizaciones son cuentas compartidas con varios repositorios en cuales un grupo de personas pueden trabajar juntos, a través de sus cuentas individuales.\nLos integrantes de las organizaciones tienen distintos roles (dueños, miembros, etc.) con distintos niveles de privilegio o de accesos a los repos.\nEn el contexto de este curso, utilizaremos a la organización “aid-austral-2024” administraremos las entregas de la tareas.\nRecibirán una invitación por email para sumarse a la misma."
  },
  {
    "objectID": "taller-git.html#los-issues-de-github",
    "href": "taller-git.html#los-issues-de-github",
    "title": "Sistemas de control de versiones y de trabajo colaborativo",
    "section": "6.5 Los issues de GitHub",
    "text": "6.5 Los issues de GitHub\n\nLos repos en GitHub tienen una página de issues (asuntos o problemas), que sirven para que integrantes del mismo equipo de trabajo (u otros si el repo es público) puedan comunicar por ese canal inconvenientes que encuentren, sugerencias, tareas por hacer, etc.\nPara cada issue se puede abrir un canal de discusión, con la posibilidad de etiquetar a personas, commits, pull-requests, etc.\nUn issue termina siendo un medio para organizar el trabajo en equipo.\nUna vez que el tema fue finalizado, se cierra el issue.\nGeneralmente, resulta ser un medio cómodo para contactar a algún autor y para conseguir una respuesta rápida.\n\n\n\n\n\n\n\nEjercicio 2\n\n\n\nBuscar en GitHub el repositorio correspondiente al desarrollo de cualquier paquete de R de su interés (por ejemplo, el de ggplot2) y resolver las siguientes consignas:\n\nIdentificar y explorar el archivo README. ¿Qué tipo de información o contenido presenta?\nIdentificar cuántas personas contribuyen al repo y cuántos forks se han hecho.\n¿Cuántos commits se han hecho en toda la historia del repo?\n¿Cuándo fue el último commit realizado? ¿Qué dice su mensaje? ¿Qué archivos y qué líneas en esos archivos modificó? ¿Quién fue el/la autor/a?\n¿Cuántos issues abiertos hay? Entrar a alguno que presente al menos dos comentarios y discernir sobre qué se trata. Describir la forma de interacción entre las personas involucradas e identificar en qué estado se encuentra el issue.\n¿Cuántos issues cerrados hay? Entrar a alguno que presente al menos dos comentarios y discernir sobre qué se trata. Describir la forma de interacción entre las personas involucradas e identificar quién y por qué lo cerró.\n¿Cuántos pull requests abiertos hay? Elegir uno y explorarlo, para identificar quién lo hizo y de qué se trata."
  },
  {
    "objectID": "taller-git-extra.html",
    "href": "taller-git-extra.html",
    "title": "Otras cuestiones relacionadas",
    "section": "",
    "text": "Nota\n\n\n\nEsta sección contiene información sobre otros aspectos relacionados a Git y GitHub que no abarcaremos en el taller. Sin embargo, comparto este material que me ha servido de referencia en otras ocasiones, en caso de que alguna vez pueda llegar a resultarles útil a ustedes también."
  },
  {
    "objectID": "taller-git-extra.html#git-desde-la-terminal",
    "href": "taller-git-extra.html#git-desde-la-terminal",
    "title": "Otras cuestiones relacionadas",
    "section": "1 git desde la terminal",
    "text": "1 git desde la terminal\nPodemos usar git de forma independiente de RStudio con la terminal de la computadora. Esta sección cuenta cómo realizar las tareas vistas en el taller haciendo uso exclusivo de la terminal. En Windows, conviene emplear una terminal que Git provee, llamada Git Bash.\n\n1.1 Establecer nombre de usuario y email\n\nAbrir una terminal (o GitBash en Windows) y hacer:\n\n\ngit config --global user.name 'minombre'\ngit config --global user.email 'micorreo@proveedor.com'\n\n\nEstos comandos no producen ninguna salida. Para verificar que los registros fueron hechos: git config --global --list.\n\n\n\n1.2 Administrar credenciales\n\nSin la ayuda del paquete de R gitcreds no es tan fácil encargarse del PAT y tal vez incluso sea más fácil recurrir al otro protocolo, SSH.\nDe todas formas, en este enlace indican cómo almacenar el PAT desde la terminal de Git Bash, instalando previamente algún sistema de manejo de credenciales.\nEn Linux, es recomendable seguir la documentación de GitHub para usar el protocolo SSH.\n\n\n\n1.3 Crear un repo\nCrear primero el repo en GitHub\n\nCrear un nuevo repo en GitHub como indicamos en esta parte.\nEn la consola de tu computadora, moverse con cd hasta la carpeta donde querés que se descargue el repo.\nClonar el repo desde GitHub a la computadora: git clone https://github.com/mpru/marcos_aprende_git\nPasarse a esta carpeta (entrar al repo): cd marcos_aprende_git\nListar sus contenidos: ls\nVer la info acerca del vínculo de este repo local con el repo en GitHub (al que se le dice remoto o remote): git remote show origin\n\nCrear primero el repo localmente\n\nEmpezar creando el repo en GitHub no es la única forma de trabajar, es la forma que hemos tomado para poder usar Git desde RStudio sin tener que recurrir a la terminal en ningún momento.\nOtra opción es empezar creando localmente el repo (sin hacer nada en GitHub antes).\nCreamos una carpeta para el repo y nos metemos en ella.\n\nmkdir marcos_aprende_git\ncd marcos_aprende_git\n\nPor supuesto, ahora no hay nada: ls\nLe indicamos a Git que inicialice un git repo para almacenar las distintas versiones de nuestros archivos: git init\nAparentemente sigue sin haber nada (ls), pero si agregamos la opción -a para que nos muestre todo, incluso los elementos ocultos de la carpeta, podremos ver el directorio .git: ls -a\nEn cualquier momento podemos hacer git status para ver el estado actual del repo: git status\nSi después de haber empezado desde cero localmente y trabajado allí, queremos vincular el repo con GitHub, seguimos así:\n\nCrear un nuevo repo en GitHub con el mismo nombre del repo local.\nDado que este repo se va a conectar a un repo local que ya existe, tiene que estar vacío, por lo tanto hay que dejar sin seleccionar la opción de “Initialize this repository with a README” y asegurarse de dejar “None” tanto en “Add .gitignore” y “Add a license”.\nCon esto, lo que está haciendo GitHub en sus servidores es:\n\n\nmkdir marcos_aprende_git\ncd marcos_aprende_git\ngit init\n\n\nEn la terminal en nuestra compu, estando posicionados dentro del repo, hacemos:\n\n\ngit remote add origin git@github.com:mpru/marcos_aprende_git.git\ngit push -u origin main\n\n\nLa primera línea le indica a Git que mi repo local tiene una versión remota (remote) en GitHub y la llama origin (podríamos ponerle otro nombre, pero se acostumbra así).\nLa segunda línea manda todo lo que tengo actualmente en mi repo a GitHub (push), al remoto llamado origin en su rama (branch) llamada main (esta observación no es importante por ahora). git push -u equivale a git push --set-upstream.\nYa estamos listos, podemos ver las configuraciones realizadas: git remote -v (equivale a git remote --verbose). Salida:\n\norigin    https://github.com/mpru/marcos_aprende_git (fetch)\norigin    https://github.com/mpru/marcos_aprende_git (push)\n\nVer info sobre el branch actual: el branch local “main” está rastreando al branch “main” en “origin”, es decir, “origin/main”: git branch -vv. Salida:\n\n* main 7b5c4c4 [origin/main] Initial commit\n1.4 Ver el estado del repo mientras estamos trabajando en él\nPodemos usar git status para ver el estado actual de nuestro repo. Salida:\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   README.md\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .gitignore\n    codigo.R\n    marcos_aprende_git.Rproj\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nPodemos usar git diff README.md para ver las diferencias. Además de estar marcado con colores, líneas nuevas tienen +, eliminadas -, y las que siguen iguales, nada. Salida:\ndiff --git a/README.md b/README.md\nindex 06e3dce..9ef6118 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,2 +1,8 @@\n-# marcos_aprende_git\n+# Un repo para aprender\n Voy a utilizar este repo para preparar el material del taller sobre RStudio, Git y GitHub.\n+\n+Agrego una lista para seguir modificando este archivo:\n+\n+- Primero\n+- Segundo\n+- Tercero\nAlgunos detalles adicionales de esta salida:\n\nLa primera línea indica que Git está haciendo algo parecido a lo que hace el comando de Unix diff para comparar versiones.\nLa segunda línea muestra los identificadores (06e3dce y 9ef6118) de las versiones que está comparando.\nLa tercera y cuarta línea muestran otra vez el archivo comparado.\n\n\n\n\n1.5 Hacer un commit\n\nPoner en stage es un poco más complicado en la terminal. Con git add &lt;nombre_archivo&gt; se pone en stage a cada archivo nuevo o modificado, con git rm &lt;nombre_archivo&gt; se pone en stage a archivos eliminados.\nYo muchas veces tomo el atajo de hacer git add ., donde el punto pone en stage a todos los archivos del repo.\nPara hacer el commit, git commit -m &lt;mensaje del commit&gt;. Si no usamos la opción -m, se abre un archivo en el editor de texto que tengamos por defecto para poder escribir el mensaje allí.\n\n\ngit add .\n\ngit status\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n    new file:   .gitignore\n    modified:   README.md\n    new file:   codigo.R\n    new file:   marcos_aprende_git.Rproj\n\ngit commit -m \"Amplié el README y agregué código\"\n\n&gt;&gt;&gt; git commit -F /tmp/RtmpFI7M9Q/git-commit-message-633651c98ace.txt\n[main bbc89e7] Amplié el README y agregué código.\n 4 files changed, 27 insertions(+), 1 deletion(-)\n create mode 100644 .gitignore\n create mode 100644 codigo.R\n create mode 100644 marcos_aprende_git.Rproj\n\nSi hacemos git status después de hacer el commit, vemos que no hay nuevos cambios después de esta última revisión (nos dice nothing to commit) y nos avisa que nuestro repo local está adelantado del repo en GitHub por un commit (es porque este cambio sólo está en nuestra compu, no en GitHub).\n\ngit status\n\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\nPodemos ver la historia reciente de nuestro repo en Git con git log:\n\ngit log\n\ncommit bbc89e7f9ddec0e330ceeb74c054cc003c2f3864 (HEAD -&gt; main)\nAuthor: mpru &lt;marcosprunello@gmail.com&gt;\nDate:   Thu Jan 23 18:06:02 2020 -0300\n\n    Amplié el README y agregué código.\n\ncommit 7b5c4c44b12236b0fe391b3a15783a1959ac2e57 (origin/main, origin/HEAD)\nAuthor: Marcos Prunello &lt;marcosprunello@gmail.com&gt;\nDate:   Wed Jan 22 08:47:06 2020 -0300\n\n    Initial commit\n\nObservación: si no ponemos nada en stage y tratamos de hacer commit, Git va a requerir que usemos git commit -a (o git commit –all) para incluir todos los archivos en el commit.\n\n\n\n1.6 Revertir cambios\n\nPara revertir un archivo a su estado en un commit anterior, debemos tomar nota del SHA del commit deseado (por ejemplo, bbc89e7 en mi ejemplo).\nEn la terminal podemos ver cómo era el archivo en el pasado (y así, por ejemplo, copiar la parte que nos interese y pegar en el archivo que estamos editando ahora): git show bbc89e7 README.md\nPodemos quedarnos con la versión completa de ese archivo tal como estaba en ese commit: git checkout bbc89e7 README.md\nEn ambos casos, se termina poniendo en stage y haciendo commit.\n\n\n\n1.7 Pull y push\n\nLos comandos para realizar estas operaciones son git pull y git push."
  },
  {
    "objectID": "taller-git-extra.html#git-clients",
    "href": "taller-git-extra.html#git-clients",
    "title": "Otras cuestiones relacionadas",
    "section": "2 git clients",
    "text": "2 git clients\n\nComo hemos visto, RStudio nos facilita con sus menúes y ventanas muchas de las actividades que necesitamos hacer con Git.\nSin embargo, hay cosas que no están incorporadas y que para hacerlas hay que usar la línea de comandos o instalar un git client, es decir, una interfaz gráfica de usuario.\nSe trata de un programa con menúes y botones que permite realizar las actividades involucradas en git y que, además, presenta diagramas que posibilitan la visualización de la evolución de las distintas versiones. Algunas opciones son GitKraken y SourceTree."
  },
  {
    "objectID": "taller-git-extra.html#branches",
    "href": "taller-git-extra.html#branches",
    "title": "Otras cuestiones relacionadas",
    "section": "3 Branches",
    "text": "3 Branches\n\nEn algunas oportunidades se desea realizar cambios en el código para explorar cosas sobre las cuales no estamos muy seguros o para probar el agregado de nuevas características al proyecto.\nEsta exploración o desarrollo puede llevar tiempo y por ahí no sabemos si va a funcionar o no.\nEntonces conviene dejar la versión actual (en la que está todo completo y andando) sin tocar y hacer un detour para experimentar por otro lado.\nPara esto existen las branches.\n\n\nUn branch o rama es una vía de desarrollo en paralelo del proyecto que uno puede abrir temporalmente para desviarse de la línea principal de desarrollo, pudiendo volver a él con un merge de lo que hicimos en la nueva branch con la principal, o descartando este nuevo camino en cualquier momento.\n\n\n\n\n\n\n\n\n\n\n\nSin darnos cuenta, ya estuvimos usando branches, porque todo repo tiene una branch por default que se llama main. Durante todo este tiempo, estuvimos implementando cambios en la main branch tanto de nuestro repo local como en el de GitHub.\nPodemos ver todas las branches que existen en el repo en la pestaña Git de RStudio y pasarnos de una a otra:\n\n\n\n\n\n\n\n\n\n\nHasta hace poco la rama principal por default se llamaba master y ahora cambió a main. Por eso en algunas figuras verás master en lugar de main.\n\n\n\n\n\nAdemás, se puede crear una nueva branch en RStudio con la ayuda de este botoncito:\n\n\n\n\n\n\n\n\n\n\n\nSin embargo, la terminal es mucho más flexible para manejarse con estas cosas de Git, por eso vamos a mostrar todo esto desde ahí.\nDespués de todo, si te encontrás en la necesidad de usar branches, ya podés considerarte un usuario avanzado: seguramente ya usás la consola o vas a necesitarla en cualquier momento.\n\n\n3.1 Crear una nueva branch\n\ngit branch lista todas las branches que existen ahora.\n\ngit branch\n* main\n\nPara crear una nueva y comenzar a trabajar en ella, elegir un nombre (por ejemplo “nueva-rama”) y hacer git branch nueva-rama.\nSe dice checkout cuando uno elige una branch para trabajar en ella. Para activar la que hemos creado recién para que podamos trabajar en ella hacemos: git checkout nueva-rama. Aparece: Switched to a new branch 'nueva-rama'.\ngit checkout -b nueva-rama resume ambos pasos anteriores en uno solo:\n\ngit checkout -b nueva-rama\nSwitched to a new branch 'nueva-rama'\n\nSi hacemos git branch, vemos que tenemos dos branches. El asterisco indica en cuál estamos trabajando ahora:\n\ngit branch\n  main\n* nueva-rama\n\nAhora nos ponemos a trabajar como siempre, hacemos los cambios en los archivos en esa carpeta local. Cada tanto, hacemos los commits: git status, git add ., git commit -m &lt;mensaje&gt;:\n\ngit status\nOn branch nueva-rama\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    practicando_branches.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\ngit add practicando_branches.txt \ngit commit -m \"nuevo archivo\"\n[nueva-rama 2e25439] nuevo archivo\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 practicando_branches.txt\n\nPodemos volver a la main branch con git checkout main. git branch tiene que mostrar el asterisco en main. Para no confundirse: si hice cambios en nueva-rama y salgo a la main branch, en el explorador de archivos de mi compu no voy a ver los cambios si abro un archivo modificado o si creé uno nuevo. Si vuelvo a la branch donde trabajé con git checkout nueva-rama, ahí sí voy a ver las modificaciones en el explorador de archivos de la compu.\n\n\n\n\n3.2 Sincronizar con GitHub\n\nPara hacer push y poder enviar a GitHub las modificaciones hechas en esta nueva branch, primero hay que avisarle de su existencia.\nEs decir, hay que setear un upstream remote para esta nueva branch, haciendo git push -u origin nueva-rama (git push -u equivale a git push --set-upstream).\n\ngit push -u origin nueva-rama\n\nCounting objects: 3, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 284 bytes | 284.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nremote: \nremote: Create a pull request for 'nueva-rama' on GitHub by visiting:\nremote:      https://github.com/mpru/marcos_aprende_git/pull/new/nueva-rama\nremote: \nTo https://github.com/mpru/marcos_aprende_git\n * [new branch]      nueva-rama -&gt; nueva-rama\nBranch 'nueva-rama' set up to track remote branch 'nueva-rama' from 'origin'.\n\n\n\n\n\n\n\n\n\n\nEsto se hace una sola vez, luego seguimos mandando sucesivos cambios con git push como hacemos habitualmente1.\n\n1 En versiones anteriores de Git, no hacía falta setear el remote para la branch, porque si no existía en GitHub, la creaba automáticamente. Esto ya no es así por default, pero si se desea tener ese comportamiento hay que configurar: git config --global push.default current.\n\n3.3 Merge con la main branch\n\nAhora tenemos dos ramas, dos vías paralelas de trabajo. Seguramente en algún momento nos interesará integrarlas.\nIntegrar branches se conoce como merge.\nEsto puede darse en dos direcciones distintas:\n\n\n3.3.1 Traer novedades de la main a mi nueva-rama\n\nSi estuvimos trabajando bastante en una branch, tal vez otros estuvieron haciendo más trabajo en la main.\nEn nuestro ejemplo, alguien creó el archivo mas-trabajo.txt en la main.\nConviene cada tanto ir trayendo las cosas nuevas de la main a nuestra branch, para que no quede muy desactualizada. Si eso pasa, crecen las chances de que lo que hagamos en la nueva-rama ya no funcione con el resto de lo que se hizo en la main, o haya que arreglar muchas cosas para que sí funcione.\nPara traer ese trabajo nuevo a nuestra branch, estando en ella, hay que hacer git merge main:\n\nls\n\ncodigo.R  otro_archivo.R README.md marcos_aprende_git.Rproj  practicando_branches.txt\n\ngit merge main -m \"traigo desde la main\"\n\nMerge made by the 'recursive' strategy.\n mas-trabajo.txt | 0\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 mas-trabajo.txt\n\nls\ncodigo.R  mas-trabajo.txt  practicando_branches.txt marcos_aprende_git.Rproj  \notro_archivo.R   README.md\n\nEs posible que en la main hayan modificado los mismos archivos que nosotros en nuestra nueva-rama. Si es así, debemos solucionar los conflictos de versiones ocasionados. Por eso es importante hacer esto de manera frecuente.\n\n\n\n3.3.2 Mandar lo de mi nueva-rama a la main\n\nCuando terminamos de trabajar en nuestra nueva-rama y ya estamos seguros de querer enviar lo que hicimos a la main branch, hacemos merge desde la main y luego la eliminamos:\n\ngit checkout main\n\nSwitched to branch 'main'\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\ngit merge nueva-rama\n\nUpdating 27b1921..1c8fe23\nFast-forward\n practicando_branches.txt | 0\n 1 file changed, 0 insertions(+), 0 deletions(-)\n create mode 100644 practicando_branches.txt\n\n\nEnvío estos cambios a GitHub:\n\ngit push\n\nCounting objects: 4, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (4/4), 481 bytes | 481.00 KiB/s, done.\nTotal 4 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), completed with 1 local object.\nTo https://github.com/mpru/marcos_aprende_git\n   ef4578e..1c8fe23  main -&gt; main\n\n\n\n\n\n\n\n\n\n\nSi ya no voy a usar más a la nueva-branch, la puedo borrar, teniendo en cuenta dos cosas:\n\nNo se puede borrar una branch estando en ella, hay que borrarla desde la main.\nGit no te deja borrar una branch que no haya sido mergeada.\n\n\n\n\nEl comando para borrar una branch es git branch -d nueva-rama:\n\ngit branch -d nueva-rama\nwarning: not deleting branch 'nueva-rama' that is not yet merged to\n         'refs/remotes/origin/nueva-rama', even though it is merged to HEAD.\nerror: The branch 'nueva-rama' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D nueva-rama'.\n\nEl mensaje anterior significa que si bien en mi repo local hice el merge, el repo remoto todavía no se enteró, por lo cual nueva-rama no está fully-merged. Tengo dos opciones para solucionarlo:\n\nHacer un push más desde nueva-rama para que el repo remoto se dé por enterado y luego borrarla:\n\ngit checkout nueva-rama \n\nSwitched to branch 'nueva-rama'\nYour branch is ahead of 'origin/nueva-rama' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\ngit push\n\nTotal 0 (delta 0), reused 0 (delta 0)\nTo https://github.com/mpru/marcos_aprende_git\n   2e25439..1c8fe23  nueva-rama -&gt; nueva-rama\n\ngit checkout main\n\nSwitched to branch 'main'\nYour branch is up to date with 'origin/main'.\n\ngit branch -d nueva-rama\nDeleted branch nueva-rama (was 1c8fe23).\n\nEliminarla a la fuerza con la opción -D (en mayúscula), desde la main:\n\ngit branch -D nueva-rama\n¡Atención! Eliminar una branch en el repo local no la elimina en GitHub y viceversa. Son virtualmente dos objetos distintos, sólo que hicimos que estén vinculadas. Para borrar también nueva-branch en el remoto:\n\ngit push origin --delete nueva-rama\nTo https://github.com/mpru/marcos_aprende_git\n - [deleted]         nueva-rama"
  },
  {
    "objectID": "taller-git-extra.html#colaborar-con-el-repo-de-otra-persona-haciendo-una-branch",
    "href": "taller-git-extra.html#colaborar-con-el-repo-de-otra-persona-haciendo-una-branch",
    "title": "Otras cuestiones relacionadas",
    "section": "4 Colaborar con el repo de otra persona haciendo una branch",
    "text": "4 Colaborar con el repo de otra persona haciendo una branch\n\nVamos a retomar el tema de las colaboraciones, viéndolo de forma más completa, haciendo fork & clone y usando branches.\nComo mencionamos antes, si hemos forkeado un repo para hacer una contribución, no conviene trabajar en la main branch del mismo, ya que en realidad no formamos parte de la línea principal de desarrollo de dicho repo.\nSe acostumbra, en cambio, a crear una nueva branch luego de hacer el fork, y hacer un pull request desde la misma.\n\n\n4.1 Configuraciones\n\nRetomemos el ejemplo visto, donde yo, con el usuario mpru (github.com/mpru), voy a contribuir al repo ProyectoInteresante de la cuenta de AprendizGit (github.com/AprendizGit2). A este repo se le suele decir upstream repo.\nPrimero, hacemos un fork del repo en GitHub (AprendizGit2/ProyectoInteresante), creando una copia que ahora me pertenece a mí, a la que se le dice origin repo: AprendizGit2/ProyectoInteresante.\nLuego, clonar el repo forkeado (AprendizGit2/ProyectoInteresante) para crear mi repo local:\n\ngit clone https://github.com/mpru/ProyectoInteresante.git\nCloning into 'ProyectoInteresante'...\nremote: Enumerating objects: 9, done.\nremote: Counting objects: 100% (9/9), done.\nremote: Compressing objects: 100% (6/6), done.\nremote: Total 9 (delta 1), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (9/9), done.\n\nEste es el estado de situación hasta el momento:\n\n\n\n\n\n\n\n\n\n\n\nYa estoy en condiciones de trabajar en mi repo local y mandar los cambios al repo remoto en mi cuenta de GitHub haciendo commits y pushes.\n¿Pero qué pasa si mientras yo estuve trabajando, AprendizGit2 también estuvo haciendo cambios en su repo, AprendizGit2/ProyectoInteresante?\nEn este caso, mi repo local no coincide con la última versión que AprendizGit2 tiene de su ProyectoInteresante.\nAntes de poder hacer mis contribuciones y crear un pull request, tengo que actualizar mi repo con un pull directamente del repo de AprendizGit2.\nPara que esta sincronización se pueda hacer, hay que setear el repo AprendizGit2/ProyectoInteresante como el upstream remote de mi copia local, de forma que quede establecida la conexión que falta entre ellos:\n\n\n\n\n\n\n\n\n\n\n\nMiro a qué repos remotos está asociado el mío local, sólo al que tengo forkeado en mi GitHub (origin):\n\ngit remote -v\n\norigin  https://github.com/mpru/ProyectoInteresante (fetch)\norigin  https://github.com/mpru/ProyectoInteresante (push)\n\nEstablezco el upstream remote, actualizo la información que mi repo local tiene sobre el upstream con fetch y pido que todos mis pulls provengan de la main branch del upstream remote en lugar de que vengan desde la main branch de mi repo forkeado (origin):\n\ngit remote add upstream https://github.com/AprendizGit2/ProyectoInteresante.git\ngit fetch upstream\ngit branch -u upstream/main\n\nControlo que haya funcionado:\n\ngit remote -v\n\norigin  https://github.com/mpru/ProyectoInteresante (fetch)\norigin  https://github.com/mpru/ProyectoInteresante (push)\nupstream    https://github.com/AprendizGit2/ProyectoInteresante.git (fetch)\nupstream    https://github.com/AprendizGit2/ProyectoInteresante.git (push)\n\n\n4.2 Flujo de trabajo\n\nAntes de empezar a trabajar, actualizo la info que tiene mi repo del upstream y hago un pull desde el upstream para traer los cambios nuevos que pudieran haber:\n\ngit pull upstream main --ff-only\n\nSi hubo cambios puedo enviarlos a mi repo remoto en GitHub (mpru/ProyectoInteresante) para que los 3 repos estén actualizados (le aclaro que el push va a origin, porque con la configuración anterior git push trataría de ir al upstream y no va a tener permiso para eso):\n\ngit push origin main\n\nListo, a trabajar. Pero no en la main branch, esa no se toca. Si quiero hacer cambios, los hago en una nueva branch:\n\ngit checkout -b micontrib\ngit branch\n\n  main\n* micontrib\n\nAhora modifico todo lo que necesite, voy haciendo commits:\n\ngit add .\ngit commit -m \"hice lo que tenia que hacer\"\n\nPuedo hacer push a mi repo en GitHub, mpru/ProyectoInteresante, pero al menos la primera vez lo voy a tener que hacer así para que allá en GitHub se enteren de que localmente tengo una nueva branch y es el destino de mis cambios:\n\ngit push -u origin micontrib\n\nYa podemos ver que la branch micontrib en GitHub tiene los nuevos cambios:\n\n\n\n\n\n\n\n\n\n\n\n\n4.3 Pull request\n\nEstamos de condiciones de sugerirle a AprendizGit2 que mire lo que hicimos en nuestra branch micontrib y que lo incorpore en su main branch a través de un merge. Es decir, vamos a hacer un pull request.\nAl hacer clic en Compare and pull request, podemos ver las diferencias entre nuestra branch y la main del repo original ProyectoInteresante del usuario AprendizGit y determinar si son compatibles:\n\n\n\n\n\n\n\n\n\n\n\nHacemos clic en Create Pull Request para pedirle a AprendizGit que tome nuestra contribución:\n\n\n\n\n\n\n\n\n\n\n\nAhora nos resta esperar que AprendizGit tome nuestra contribución o dé lugar a una discusión en la página de este pull request. Así es como le aparece a AprendizGit, y cómo hace para aceptar la contribución:\n\n\n\n\n\n\n\n\n\n\n\nYa que mi contribución fue aceptada, puedo eliminar mi branch micontrib tanto en el repo local como en mi copia remota:\n\ngit branch -d micontrib\ngit push origin --delete micontrib\n\nSi quiero seguir aportando a este repo de AprendizGit, debo actualizar mi copia local con estos cambios y todos los otros que haya podido hacer AprendizGit:\n\ngit fetch upstream\ngit pull upstream main --ff-only\ngit push origin main"
  },
  {
    "objectID": "taller-git-extra.html#conflictos",
    "href": "taller-git-extra.html#conflictos",
    "title": "Otras cuestiones relacionadas",
    "section": "5 Conflictos",
    "text": "5 Conflictos\n\nCuando se trabaja en equipo con un repo central en GitHub, cada uno hace pull para tomar la última versión del repo, implementa sus modificaciones y luego hace push para mandar los cambios a GitHub.\nPero en ese interín, la versión de GitHub pudo haber sufrido modificaciones por la contribución de otra persona.\nEn esos casos, Git nos obliga a hacer pull antes de push, para que tengamos en nuestro repo local la última versión. En ese proceso, Git automáticamente hace un merge de la versión de GitHub con la nuestra que tiene nuestros cambios.\nSi las modificaciones se dieron en distintos archivos o en distintas partes de un mismo archivo, está todo bien.\nPero si en GitHub hubo una modificación en la misma parte del archivo que cambié localmente, se produce un conflicto (de versiones).\nA estos conflictos hay que resolverlos manualmente, Git no toma ninguna decisión por nosotros.\nAl contrario, nos muestra la versión nuestra y la versión remota, y nos pide que editemos a mano el archivo en conflicto para decidir cómo debe quedar.\nEn esta página hay un ejemplo acerca de cómo se presenta un conflicto y cómo se puede solucionar."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Git + GitHub + RStudio",
    "section": "",
    "text": "¡Hola!\nEn este taller vamos a describir en qué consiste un sistema de control de versiones y trabajo colaborativo y vamos a hacer una introducción al uso de Git, GitHub y RStudio en conjunto.\nEn la sección Preparativos vas a encontrar los pasos necesarios para tener todo listo y seguir los ejemplos.\n\n\n\n\n\n\n\nPresentador\nMarcos Prunello: Soy Licenciado en Estadística (UNR) y MSc in Biomedical Informatics (Stanford University). Me dedico a la vida universitaria, trabajando en cuestiones de Estadística y Ciencia de Datos en la FCEyE-UNR y Universidad Austral.\n\n\nLicencia\n Los materiales de esta charla están bajo la licencia Creative Commons Attribution-ShareAlike 4.0 International License.\n\n\n\n\n Volver arriba"
  }
]